# raft 论文笔记
## raft背景
共识算法允许多台机器作为一个集群来工作，保证在某些机器出现状况后还能继续工作。过去的一段时间中，Paxos主导了对共识算法的讨论。但难点在于，尽管有许多尝试使它更容易理解，但Paxos是相当难以理解的。所以，系统建设者们为了让算法明显地体现它的作用，在raft设计的过程中，通过分解（Raft 分解领导者选举、日志复制和安全）和减少状态空间（相对于Paxos，Raft降低了非确定性的程度以及服务器之间不一致的方式）来提高可理解性。<br>
raft的一些feature：<br>
Strong leader:Raft采用了更强的领导形式。如日志条目只从领导者流向其他服务器，这简化了对复制的日志的管理。<br>
Leader election：Raft 使用随机的计时器来选举领导者。<br>
Membership changes:使用了一种新的联合共识的方法改变集群中的服务器集。<br>
## 复制状态机
服务器集群上的状态机处理相同状态的相同副本，这样即使一些服务器停机，集群也能继续运行。复制状态机被用来解决分布式系统中的各种容错问题。每台服务器存储一个包含一系列命令的日志，其状态机按顺序执行这些命令。每个日志都包含相同顺序的命令，所以每个状态机处理相同的命令序列。保持复制日志的一致性是共识算法的工作。即使一些服务器fail,只要日志保证一致，命令被正确复刻，每个服务器的状态机按照日志顺序处理它们，这些服务器就能形成一个单一的、高度可靠的状态机。<br>
实际系统的共识算法特性：<br>
1.在所有非拜占庭条件下，包括网络延迟、分区、数据包丢失、重复和重新排序，它们都能确保安全（永远不会返回错误的结果）。<br>
2.只要有任何一个服务器在运行，它们就能完全发挥作用（可用）。<br>
3.大多数服务器都在运行，并且可以相互通信和与客户通信。如五台服务器容忍两台服务器故障，它们可能会在以后重新恢复状态。<br>
4.不依赖时间来确保日志的一致性：时钟故障和极端的信息延迟在最坏的情况下会导致可用性问题。<br>
5.正常情况下，只要集群中的大多数服务器对单轮远程调用作出反应，这个命令就可以完成，少数缓慢的服务器不会影响系统的整体性能。<br>
## Paxos的缺陷
第一个缺点是，Paxos特别难理解。很少有人能成功地理解它，而且是在付出巨大努力之后。<br>
Paxos的第二个问题是，它没有为建立实际的实现提供一个良好的基础。原因之一是没有广泛认同的多Paxos的算法。Paxos架构对于构建实用的系统来说是一个糟糕的架构；这是单树分解的另一个结果。例如，独立地选择一组日志条目，然后将它们拼接成一个连续的日志，这没有什么好处；这只是增加了复杂性。更简单、更有效的做法是设计一个围绕着日志的系统，新的条目以一个受限的顺序依次添加。<br>
## Raft设计
### Raft相比Paxos优化的设计思想
1.采用分解的思想：在可能的情况下，把问题分成独立的部分，可以相对独立地解决和理解。例如，在Raft中，我们将领袖选举、日志复制、安全和成员变化分开。<br>
2.通过减少需要考虑的状态数量来简化状态空间,使用随机来简化Raft领袖选举。
### raft共识算法
Raft是一种管理复制日志的算法。
1.Raft首先通过选举一个领导者来实现共识，然后让该领导者来完全负责管理日志的复制。领导从客户端接受新的日志条目，将其复制到其他服务器上。拥有一个领导者可以简化对复制日志的管理。例如，领导者可以决定将新条目放置在哪里，而不需要咨询其他服务器，并将数据以一种简单的方式传给其他服务器。<br>
2.领导者可能fail或者与其他服务器断开连接，在这种情况下，会在剩下的服务器选出一个新的领导者。
Raft将共识问题分解为三个相对独立的子问题
1.领导者选举：当现有领导者失败时，必须选择一个新的领导者。
2.日志复制：领导者必须接受来自客户端的日志条目，并在集群中复制它们，迫使其他日志与自己的一致。
3.安全性：
Raft的关键安全属性：
1.选举安全：在一个特定的任期内，最多可以选出一位领导人。
2.追加日志：领导者永远不会覆盖或删除其日志中的条目，它只添加新条目。
3.日志匹配：如果两个日志包含一个具有相同的索引和任期，那么这两份日志的所有条目都是相同的。
4.领导者完整性：如果一个日志条目在一个给定的任期中被提交，那么这个词条必须出现在接下来所有更高任期的领导者的日志中。
5.状态机安全：如果一个服务器在它的状态机上应用了一个给定索引的日志条目，那么其他服务器将永远不会为同一索引应用不同的日志条目。
#### raft服务器属性
1.服务器状态：
所有服务器上的持久化状态：
currentTerm：服务器所看到的最新的任期。初始化为0，单调增加。
votedFor：在当前任期内投票选择的候选者ID(如果没有，则为空)。
log[]:每个条目包含状态机的命令，以及条目被领导者收到的任期（第一个索引是1）。
所有服务器上的易失性状态（内存）：
commitIndex：已知被提交的最高日志条目的索引（初始化为0，单调地增加）。
lastApplied：最后应用于状态机的最高日志条目的索引（初始化为0，单调增加）。
领导者上的易失性状态（内存）：(选举后重新初始化)
nextIndex[]:对于每个服务器，下一个发送给该服务器的日志条目的索引（初始化为领导者最后一条日志索引+1)。
matchIndex[]:对于每个服务器，在服务器上已知的被复制的最高日志条目的索引(初始化为0，单调地增加)。
2.RequestVote RPC（候选人用来收集选票）
<br>
Arguments：
term：候选者的任期
candidateId：候选者ID
lastLogIndex：候选者最后一条日志条目的索引
lastLogTerm：候选者的最后一次日志条目的任期
<br>
Results:
term：当前任期，以便候选者自我更新
voteGranted：true 表示候选者获得了选票
接受者的操作：
(1).如果服务器的currentTerm大于候选人的term，返回false.
(2).如果服务器的votedFor是null或发来的候选人ID，且候选人的日志至少和接收者的日志一样新，则给予投票.
(3).其他情况，返回false.

3.AppendEntries RPC（由领导者调用以复制日志条目，也用作心跳）
term 
4.服务器的规则

#### raft基础
在任何时候，每个服务器都处于领导者、追随者、或候选者三种状态中的一种。在正常操作中，有只有一个领导者，其他所有的服务器都是追随者。
追随者是被动的：他们自己不发出任何请求，只是对领导者和候选者的请求做出回应。
领导者处理所有客户端的请求（如果客户端联系追随者，追随者将其转给领导者）。
候选人，被用来选举一个新的领导者。


