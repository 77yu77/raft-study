# raft 论文笔记
## raft背景
共识算法允许多台机器作为一个集群来工作，保证在某些机器出现状况后还能继续工作。过去的一段时间中，Paxos主导了对共识算法的讨论。但难点在于，尽管有许多尝试使它更容易理解，但Paxos是相当难以理解的。所以，系统建设者们为了让算法明显地体现它的作用，在raft设计的过程中，通过分解（Raft 分解领导者选举、日志复制和安全）和减少状态空间（相对于Paxos，Raft降低了非确定性的程度以及服务器之间不一致的方式）来提高可理解性。<br>
raft的一些feature：<br>
Strong leader:Raft采用了更强的领导形式。如日志条目只从领导者流向其他服务器，这简化了对复制的日志的管理。<br>
Leader election：Raft 使用随机的计时器来选举领导者。<br>
Membership changes:使用了一种新的联合共识的方法改变集群中的服务器集。<br>
## 复制状态机
服务器集群上的状态机处理相同状态的相同副本，这样即使一些服务器停机，集群也能继续运行。复制状态机被用来解决分布式系统中的各种容错问题。每台服务器存储一个包含一系列命令的日志，其状态机按顺序执行这些命令。每个日志都包含相同顺序的命令，所以每个状态机处理相同的命令序列。保持复制日志的一致性是共识算法的工作。即使一些服务器fail,只要日志保证一致，命令被正确复刻，每个服务器的状态机按照日志顺序处理它们，这些服务器就能形成一个单一的、高度可靠的状态机。<br>
实际系统的共识算法特性：<br>
1.在所有非拜占庭条件下，包括网络延迟、分区、数据包丢失、重复和重新排序，它们都能确保安全（永远不会返回错误的结果）。<br>
2.只要有任何一个服务器在运行，它们就能完全发挥作用（可用）。<br>
3.大多数服务器都在运行，并且可以相互通信和与客户通信。如五台服务器容忍两台服务器故障，它们可能会在以后重新恢复状态。<br>
4.不依赖时间来确保日志的一致性：时钟故障和极端的信息延迟在最坏的情况下会导致可用性问题。<br>
5.正常情况下，只要集群中的大多数服务器对单轮远程调用作出反应，这个命令就可以完成，少数缓慢的服务器不会影响系统的整体性能。<br>
## Paxos的缺陷
第一个缺点是，Paxos特别难理解。很少有人能成功地理解它，而且是在付出巨大努力之后。<br>
Paxos的第二个问题是，它没有为建立实际的实现提供一个良好的基础。原因之一是没有广泛认同的多Paxos的算法。Paxos架构对于构建实用的系统来说是一个糟糕的架构；这是单树分解的另一个结果。例如，独立地选择一组日志条目，然后将它们拼接成一个连续的日志，这没有什么好处；这只是增加了复杂性。更简单、更有效的做法是设计一个围绕着日志的系统，新的条目以一个受限的顺序依次添加。<br>
## Raft设计
### Raft相比Paxos优化的设计思想
1.采用分解的思想：在可能的情况下，把问题分成独立的部分，可以相对独立地解决和理解。例如，在Raft中，我们将领袖选举、日志复制、安全和成员变化分开。<br>
2.通过减少需要考虑的状态数量来简化状态空间,使用随机来简化Raft领袖选举。
### raft共识算法
Raft是一种管理复制日志的算法。
1.Raft首先通过选举一个领导者来实现共识，然后让该领导者来完全负责管理日志的复制。领导从客户端接受新的日志条目，将其复制到其他服务器上。拥有一个领导者可以简化对复制日志的管理。例如，领导者可以决定将新条目放置在哪里，而不需要咨询其他服务器，并将数据以一种简单的方式传给其他服务器。<br>
2.领导者可能fail或者与其他服务器断开连接，在这种情况下，会在剩下的服务器选出一个新的领导者。
Raft将共识问题分解为三个相对独立的子问题
1.领导者选举：当现有领导者失败时，必须选择一个新的领导者。
2.日志复制：领导者必须接受来自客户端的日志条目，并在集群中复制它们，迫使其他日志与自己的一致。
3.安全性：
Raft的关键安全属性：
1.选举安全：在一个特定的任期内，最多可以选出一位领导人。
2.追加日志：领导者永远不会覆盖或删除其日志中的条目，它只添加新条目。
3.日志匹配：如果两个日志包含一个具有相同的索引和任期，那么这两份日志的所有条目都是相同的。
4.领导者完整性：如果一个日志条目在一个给定的任期中被提交，那么这个词条必须出现在接下来所有更高任期的领导者的日志中。
5.状态机安全：如果一个服务器在它的状态机上应用了一个给定索引的日志条目，那么其他服务器将永远不会为同一索引应用不同的日志条目。
#### raft基础
在任何时候，每个服务器都处于领导者、追随者、或候选者三种状态中的一种。在正常操作中，有只有一个领导者，其他所有的服务器都是追随者。追随者是被动的：他们自己不发出任何请求，只是对领导者和候选者的请求做出回应。领导者处理所有客户端的请求（如果客户端联系追随者，追随者将其转给领导者）。候选人，被用来选举一个新的领导者。<br>
Raft将时间划分为任意长度的任期，每个任期以选举开始，在选举中，一个或多个候选人试图成为领导者。如果某位候选人在选举中获胜，那么他将在剩余的任期内担任领导者。在某些情况下选举会导致投票的分裂。在这种情况下，任期将在没有领导者的情况下结束，新的任期（重新选举）将很快开始。Raft会确保在一个特定的任期内最多有一个领导者。<br>
某些情况下，一个服务器可能不会观察到一次选举，甚至是整个任期。任期在Raft中充当逻辑时钟，它们允许服务器检测过时的信息，如过时的领导。服务器都会存储一个当前的任期编号，该编号随着时间的推移单调地随时间增加。每当服务器进行通信时，就会交换当前的任期，更新到比较新的任期去。如果一个候选者或领导者发现它的任期已经过期，它将立即恢复到跟随者状态。如果一个服务器收到一个带有过时的任期的请求，它将拒绝该请求。<br>
Raft服务器使用远程过程调用（RPCs）进行通信，基本的共识算法只需要两种RPCs。RequestVote RPCs由候选人在选举期间发起，AppendEntries RPCs由领导者发起，用于复制日志条目并提供一种心跳形式。此外还会增加了第三个RPC，用于在服务器之间传输快照。如果服务器没有及时收到响应，它们会重试RPC，并以并行方式发出RPC，以获得最佳性能。<br>
#### leader 选举详情
#### raft服务器属性
1.服务器状态：
所有服务器上的持久化状态：
currentTerm：服务器所看到的最新的任期。初始化为0，单调增加。
votedFor：在当前任期内投票选择的候选者ID(如果没有，则为空)。
log[]:每个条目包含状态机的命令，以及条目被领导者收到的任期（第一个索引是1）。
所有服务器上的易失性状态（内存）：
commitIndex：已知被提交的最高日志条目的索引（初始化为0，单调地增加）。
lastApplied：最后应用于状态机的最高日志条目的索引（初始化为0，单调增加）。
领导者上的易失性状态（内存）：(选举后重新初始化)
nextIndex[]:对于每个服务器，下一个发送给该服务器的日志条目的索引（初始化为领导者最后一条日志索引+1)。
matchIndex[]:对于每个服务器，在服务器上已知的被复制的最高日志条目的索引(初始化为0，单调地增加)。
2.RequestVote RPC（候选人用来收集选票）
<br>
Arguments：<br>
term：候选者的任期<br>
candidateId：候选者ID<br>
lastLogIndex：候选者最后一条日志条目的索引<br>
lastLogTerm：候选者的最后一次日志条目的任期<br>
<br>
Results:<br>
term：当前任期，以便候选者自我更新<br>
voteGranted：true 表示候选者获得了选票<br>
接受者的操作：<br>
(1).如果服务器的currentTerm大于候选人的term，返回false.<br>
(2).如果服务器的votedFor是null或发来的候选人ID，且候选人的日志至少和接收者的日志一样新，则给予投票.<br>
(3).其他情况，返回false.<br>
<br>
3.AppendEntries RPC（由领导者调用以复制日志条目，也用作心跳）<br>
Arguments:<br>
term：领导者的任期。<br>
leaderId:领导者Id,方便追随者重定向客户端请求。<br>
prevLogIndex：紧接在新日志之前的日志条目的索引。<br>
prevLogTerm：prevLogIndex条目的任期。<br>
entries[]：要存储的日志条目（心跳时为空，为了提高效率，可以发送多条）。<br>
leaderCommit：leader的commitIndex。<br>
<br>
Results:<br>
term:当前任期，方便leader自我更新。<br>
success：标识位，表示追随者是否成功更新。<br>
<br>
接受者的操作：<br>
(1).如果领导者的任期小于追随者当前任期，返回false。<br>
(2).如果日志不包含prevLogIndex的条目，并且其当前任期与prevLogTerm匹配，则回复false。<br>
(3).如果一个现有的条目与一个新的条目冲突（相同的索引，但不同的任期），则删除现有的条目和它后面的所有条目。<br>
(4).现有日志尚未出现的任何新条目要添加。<br>
(5).如果 leaderCommit > commitIndex，则设置 commitIndex = min(leaderCommit, index of last new entry)。<br>
<br>
4.服务器的规则<br>
对于所有服务器：
(1). 如果 commitIndex > lastApplied: 增加 lastApplied, 应用 log[lastApplied]到状态机。
(2). 如果RPC请求或响应包含term > currentTerm, 则设置 currentTerm = term, 且当前服务器转换为跟随者。
对于追随者：
(1). 对来自候选人和领导者的RPC做出响应。
(2). 如果没有收到来自当前领导者的AppendEntries RPC或授予候选人投票权而选举超时，转换为候选者。
对于候选者：
(1). 在转换为候选者时，开始选举。
(2). 递增currentTerm，并为自己投票，将选举定时器重置。
(3). 向所有其他服务器发送RequestVote RPCs。
(4). 如果收到大多数服务器的投票：成为领导者。
(5). 如果收到来自新领导者的AppendEntries RPC：转换为跟随者。
(6). 如果选举超时：开始新的选举。
对于领导者：
(1). 选举后：在空闲期间重复发送最初的空AppendEntries RPCs(心跳)到每个服务器，以防止选举超时。
(2). 如果收到来自客户端的命令：将条目追加到本地日志，在条目应用于状态机后作出响应。
(3). 如果最后的日志索引≥跟随者的NextIndex：发送AppendEntries RPC，里面包括从nextIndex开始的日志条目。
(4). 如果RPC回复成功：为跟随者更新对应的nextIndex和matchIndex。如果AppendEntries RPC因为日志的不一致而失败，递减nextIndex并重试。
(5). 如果存在一个N，使得N>commitIndex，以及大多数的matchIndex[i] ≥ N，并且 log[N].term == currentTerm：设置commitIndex = N。



