# raft 论文笔记
## raft背景
共识算法允许多台机器作为一个集群来工作，保证在某些机器出现状况后还能继续工作。过去的一段时间中，Paxos主导了对共识算法的讨论。但难点在于，尽管有许多尝试使它更容易理解，但Paxos是相当难以理解的。所以，系统建设者们为了让算法明显地体现它的作用，在raft设计的过程中，通过分解（Raft 分解领导者选举、日志复制和安全）和减少状态空间（相对于Paxos，Raft降低了非确定性的程度以及服务器之间不一致的方式）来提高可理解性。<br>
raft的一些feature：<br>
Strong leader:Raft采用了更强的领导形式。如日志条目只从领导者流向其他服务器，这简化了对复制的日志的管理。<br>
Leader election：Raft 使用随机的计时器来选举领导者。<br>
Membership changes:使用了一种新的联合共识的方法改变集群中的服务器集。<br>
## 复制状态机
服务器集群上的状态机处理相同状态的相同副本，这样即使一些服务器停机，集群也能继续运行。复制状态机被用来解决分布式系统中的各种容错问题。每台服务器存储一个包含一系列命令的日志，其状态机按顺序执行这些命令。每个日志都包含相同顺序的命令，所以每个状态机处理相同的命令序列。保持复制日志的一致性是共识算法的工作。即使一些服务器fail,只要日志保证一致，命令被正确复刻，每个服务器的状态机按照日志顺序处理它们，这些服务器就能形成一个单一的、高度可靠的状态机。<br>
实际系统的共识算法特性：<br>
1.在所有非拜占庭条件下，包括网络延迟、分区、数据包丢失、重复和重新排序，它们都能确保安全（永远不会返回错误的结果）。<br>
2.只要有任何一个服务器在运行，它们就能完全发挥作用（可用）。<br>
3.大多数服务器都在运行，并且可以相互通信和与客户通信。如五台服务器容忍两台服务器故障，它们可能会在以后重新恢复状态。<br>
4.不依赖时间来确保日志的一致性：时钟故障和极端的信息延迟在最坏的情况下会导致可用性问题。<br>
5.正常情况下，只要集群中的大多数服务器对单轮远程调用作出反应，这个命令就可以完成，少数缓慢的服务器不会影响系统的整体性能。<br>
## Paxos的缺陷
第一个缺点是，Paxos特别难理解。很少有人能成功地理解它，而且是在付出巨大努力之后。<br>
Paxos的第二个问题是，它没有为建立实际的实现提供一个良好的基础。原因之一是没有广泛认同的多Paxos的算法。Paxos架构对于构建实用的系统来说是一个糟糕的架构；这是单树分解的另一个结果。例如，独立地选择一组日志条目，然后将它们拼接成一个连续的日志，这没有什么好处；这只是增加了复杂性。更简单、更有效的做法是设计一个围绕着日志的系统，新的条目以一个受限的顺序依次添加。<br>
## Raft设计
### Raft相比Paxos优化的设计思想
1.采用分解的思想：在可能的情况下，把问题分成独立的部分，可以相对独立地解决和理解。例如，在Raft中，我们将领袖选举、日志复制、安全和成员变化分开。<br>
2.通过减少需要考虑的状态数量来简化状态空间,使用随机来简化Raft领袖选举。
### raft共识算法
Raft是一种管理复制日志的算法。<br>
1.Raft首先通过选举一个领导者来实现共识，然后让该领导者来完全负责管理日志的复制。领导从客户端接受新的日志条目，将其复制到其他服务器上。拥有一个领导者可以简化对复制日志的管理。例如，领导者可以决定将新条目放置在哪里，而不需要咨询其他服务器，并将数据以一种简单的方式传给其他服务器。<br>
2.领导者可能fail或者与其他服务器断开连接，在这种情况下，会在剩下的服务器选出一个新的领导者。<br>
Raft将共识问题分解为三个相对独立的子问题<br>
1.领导者选举：当现有领导者失败时，必须选择一个新的领导者。<br>
2.日志复制：领导者必须接受来自客户端的日志条目，并在集群中复制它们，迫使其他日志与自己的一致。<br>
3.安全性：<br>
Raft的关键安全属性：<br>
1.选举安全：在一个特定的任期内，最多可以选出一位领导人。<br>
2.追加日志：领导者永远不会覆盖或删除其日志中的条目，它只添加新条目。<br>
3.日志匹配：如果两个日志包含一个具有相同的索引和任期，那么这两份日志的所有条目都是相同的。<br>
4.领导者完整性：如果一个日志条目在一个给定的任期中被提交，那么这个词条必须出现在接下来所有更高任期的领导者的日志中。<br>
5.状态机安全：如果一个服务器在它的状态机上应用了一个给定索引的日志条目，那么其他服务器将永远不会为同一索引应用不同的日志条目。<br>
#### raft基础
在任何时候，每个服务器都处于领导者、追随者、或候选者三种状态中的一种。在正常操作中，有只有一个领导者，其他所有的服务器都是追随者。追随者是被动的：他们自己不发出任何请求，只是对领导者和候选者的请求做出回应。领导者处理所有客户端的请求（如果客户端联系追随者，追随者将其转给领导者）。候选人，被用来选举一个新的领导者。<br>
Raft将时间划分为任意长度的任期，每个任期以选举开始，在选举中，一个或多个候选人试图成为领导者。如果某位候选人在选举中获胜，那么他将在剩余的任期内担任领导者。在某些情况下选举会导致投票的分裂。在这种情况下，任期将在没有领导者的情况下结束，新的任期（重新选举）将很快开始。Raft会确保在一个特定的任期内最多有一个领导者。<br>
某些情况下，一个服务器可能不会观察到一次选举，甚至是整个任期。任期在Raft中充当逻辑时钟，它们允许服务器检测过时的信息，如过时的领导。服务器都会存储一个当前的任期编号，该编号随着时间的推移单调地随时间增加。每当服务器进行通信时，就会交换当前的任期，更新到比较新的任期去。如果一个候选者或领导者发现它的任期已经过期，它将立即恢复到跟随者状态。如果一个服务器收到一个带有过时的任期的请求，它将拒绝该请求。<br>
Raft服务器使用远程过程调用（RPCs）进行通信，基本的共识算法只需要两种RPCs。RequestVote RPCs由候选人在选举期间发起，AppendEntries RPCs由领导者发起，用于复制日志条目并提供一种心跳形式。此外还会增加了第三个RPC，用于在服务器之间传输快照。如果服务器没有及时收到响应，它们会重试RPC，并以并行方式发出RPC，以获得最佳性能。<br>
#### leader 选举详情
当服务器启动时，它们开始作为跟随者。服务器只要收到来自领导者或候选人的有效RPC，就一直处于跟随者状态（重置定时器）。领导者会定期发送心跳（AppendEntries RPCs，不携带日志条目）到所有追随者，以重置定时器防止超时，如果一个跟随者在一段时期内没有收到通信，称为选举超时。此时它就认为没有可行的领导者，并开始选举，以选择一个新的领导者。<br>
定时器超时时，追随者增加其当前的期，并转换为候选状态。然后，它为自己投票并向集群中的其他每个服务器发出RequestVote RPCs。候选人继续处于这个状态，直到发生以下三种情况之一：<br>
(a) 它赢得选举<br>
(b) 另一个服务器确立了自己的领导地位<br>
(c) 一段时间内没有赢家<br>
如果一个候选人在同一任期内获得了整个集群中大多数服务器的投票，那么它就赢得了选举。每台服务器在给定的任期内最多为一名候选人投票，以先来后到为原则,多数规则确保最多只有一名候选人能在某届选举中获胜。成为领导者后先向其他服务器发一次心跳来防止新的选举。<br>
在等待投票的过程中，候选人可能会收到一个来自另一个服务器的 AppendEntries RPC，声称自己是领导者。如果领导者的任期（包括在其RPC中）至少是与候选人的当前任期一样大，那么候选人就会就承认该领导者是合法的，并返回到跟随者状态，而如果领导者发来的任期比候选人小，那么候选人发送false，并继续处于候选状态<br>
还有一种情况，如果许多追随者同时成为候选人，选票就会被分割，从而使没有候选人获得多数票，这种情况发生时，每个候选人都将超时，并通过增加其任期和启动新一轮的RequestVote RPC来开始新的选举。然而，如果没有额外的措施，分裂的投票可以无限期地重复。为了解决这种问题，Raft提出使用随机的选举超时来确保分歧票的情况很少，为了从一开始就防止分裂投票，选举超时被从一个固定的时间间隔中随机选择，因此在大多数情况下，只有一个服务器会超时。它赢得了选举，并在其他服务器超时前发送心跳。每个候选人也会在选举开始时重新启动其随机的选举超时。
#### 日志复制详情
一旦一个领导者被选出，它就开始监听客户端请求。每个客户请求都包含一个命令，由复制状态机执行。领导者将该命令作为一个新条目附加到它的日志中，然后向其他每个服务器并行地发出AppendEntries RPCs来复制该条目。当该条目已经被安全复制后，领导者将该条目应用于其状态机，并将执行的结果返回给客户端。如果跟随者崩溃、运行缓慢或者网络数据包丢失，领导者会无限期地重试AppendEntries RPCs（甚至在它已经响应了）直到所有跟随者最终存储了所有的日志条目。每个日志条目都存储了一个状态机命令，以及领导者收到该条目时的任期，这用来检测日志之间的不一致，而日志条目中的整数索引用于识别它在日志中的位置。<br>
领导者决定何时将日志条目应用于状态机是安全的，这样的条目是committed。Raft保证所提交的条目是持久化的并且最终会被所有可用的状态机执行。当领导者创建该条目后，会将其复制到大多数的服务器上，包括由以前的领导者创建而一些服务器没有复制的条目。一旦跟随者得知一个日志条目被提交，它就会按日志顺序将该条目应用到其本地状态机。<br>
Raft的日志机制不仅保证不同服务器上的日志有高度的一致性，而且使其更具可预测性。Raft维护以下属性来维护其日志安全性：<br>
1.如果不同日志中的两个条目具有相同的索引和任期，那么它们存储的是同一命令。<br>
2.如果不同日志中的两个条目具有相同的索引和任期，那么这些日志在所有前面的条目相同。<br>
第一个属性来源于：一个领导者在一个给定的任期中最多创建一个具有给定日志索引的条目，而日志条目不会改变它们在日志中的位置。第二个属性由AppendEntries执行的简单一致性检查来保证。当发送一个AppendEntries RPC时，除了发送新的日志外，还会发送在新条目之前的日志条目的索引和任期，如果跟随者在其日志中没有找到具有相同索引和术语的条目，那么它将拒绝新条目。<br>
在正常运行期间，领导者和追随者的日志保持一致。所以AppendEntries的一致性检查不会失败。然而，领导者的崩溃会使日志不一致（旧的领导者可能没有完全
复制其日志中的所有条目）,这些不一致会在一系列领导者和追随者的崩溃中加剧。跟随者的日志可能缺少在领导者身上存在的条目，也可能有多余的条目，而这些条目在领导者身上要么是不存在的，要么两者都有。日志中的缺失和多余的条目可能跨越了多个任期。<br>
//
在Raft中，领导者通过强迫跟随者重复自己的日志来处理不一致的问题。
跟随者的日志与自己的日志重复。这意味着
跟随者日志中的冲突条目将被覆盖
用领导者日志中的条目覆盖。第5.4节将表明
如果再加上一个限制，这就是安全的。
为了使跟随者的日志与自己的日志保持一致。
领导者必须找到两个日志一致的最新日志条目。
日志的一致性，删除追随者日志中的任何条目，并将追随者的日志发送至
之后的任何条目，并向追随者发送追随者的所有条目
后的所有条目。所有这些动作都是为了响应
对AppendEntries所进行的一致性检查
RPCs进行的一致性检查。领导为每个跟随者维护一个nextIndex。
它是领导者将发送给跟随者的下一个日志条目的索引。
发送给该跟随者的下一个日志条目的索引。当一个领导者第一次上台时。
它将所有的nextIndex值初始化为其日志中最后一个索引之后的索引。
它的日志中的最后一个索引（图7中的11）。如果一个跟随者的日志
与领导者的不一致，AppendEntries一致性检查将在下一个AppendEntries RPC中失败。在拒绝之后，领导者会递减NextIndex并重试
AppendEntries RPC。最终，NextIndex将达到
一个领导者和追随者日志匹配的点。当
当这种情况发生时，AppendEntries就会成功，这就删除了
移除跟随者日志中任何冲突的条目，并从领导者日志中添加
从领导者的日志中添加条目（如果有的话）。一旦AppendEntries
成功后，跟随者的日志就与领导者的一致了。
并且在余下的时间里保持这种状态。
如果需要，该协议可以被优化以减少
被拒绝的AppendEntries RPC的数量。例如。
当拒绝一个AppendEntries请求时，跟随者
7
可以包括冲突条目的术语和该术语的第一个
它为该词条存储的第一个索引。有了这些信息
领导者可以递减 nextIndex 以绕过该术语中的所有冲突条目；每个有冲突条目的术语需要一个 AppendEntries RPC。
而不是每个词条一个RPC。
而不是每个条目一个RPC。在实践中，我们怀疑这种优化是否有必要，因为故障发生的频率很低
而且不太可能有很多不一致的条目。
有了这个机制，领导者不需要采取任何
领导者不需要采取任何特别的行动来恢复日志的一致性，当它来到
力。它只是开始正常的操作，而日志会自动收敛以应对AppendEntries一致性检查的失败。一个领导者从不覆盖或
删除自己日志中的条目（图3中的Leader Append-Only
图3中的属性）。
这种日志复制机制表现出第二节中所描述的理想的
第2节中描述的共识属性：只要大多数服务器都在运行，Raft就可以接受、复制和应用新的日志条目；在正常情况下，一个新条目
在正常情况下，一个新条目可以通过单轮RPCs复制到集群的大部分；而且一个缓慢的跟随者不会
影响性能。
//
#### raft服务器属性
1.服务器状态：
所有服务器上的持久化状态：
currentTerm：服务器所看到的最新的任期。初始化为0，单调增加。
votedFor：在当前任期内投票选择的候选者ID(如果没有，则为空)。
log[]:每个条目包含状态机的命令，以及条目被领导者收到的任期（第一个索引是1）。
所有服务器上的易失性状态（内存）：
commitIndex：已知被提交的最高日志条目的索引（初始化为0，单调地增加）。
lastApplied：最后应用于状态机的最高日志条目的索引（初始化为0，单调增加）。
领导者上的易失性状态（内存）：(选举后重新初始化)
nextIndex[]:对于每个服务器，下一个发送给该服务器的日志条目的索引（初始化为领导者最后一条日志索引+1)。
matchIndex[]:对于每个服务器，在服务器上已知的被复制的最高日志条目的索引(初始化为0，单调地增加)。
2.RequestVote RPC（候选人用来收集选票）
<br>
Arguments：<br>
term：候选者的任期<br>
candidateId：候选者ID<br>
lastLogIndex：候选者最后一条日志条目的索引<br>
lastLogTerm：候选者的最后一次日志条目的任期<br>
<br>
Results:<br>
term：当前任期，以便候选者自我更新<br>
voteGranted：true 表示候选者获得了选票<br>
接受者的操作：<br>
(1).如果服务器的currentTerm大于候选人的term，返回false.<br>
(2).如果服务器的votedFor是null或发来的候选人ID，且候选人的日志至少和接收者的日志一样新，则给予投票.<br>
(3).其他情况，返回false.<br>
<br>
3.AppendEntries RPC（由领导者调用以复制日志条目，也用作心跳）<br>
Arguments:<br>
term：领导者的任期。<br>
leaderId:领导者Id,方便追随者重定向客户端请求。<br>
prevLogIndex：紧接在新日志之前的日志条目的索引。<br>
prevLogTerm：prevLogIndex条目的任期。<br>
entries[]：要存储的日志条目（心跳时为空，为了提高效率，可以发送多条）。<br>
leaderCommit：leader的commitIndex。<br>
<br>
Results:<br>
term:当前任期，方便leader自我更新。<br>
success：标识位，表示追随者是否成功更新。<br>
<br>
接受者的操作：<br>
(1).如果领导者的任期小于追随者当前任期，返回false。<br>
(2).如果日志不包含prevLogIndex的条目，并且其当前任期与prevLogTerm匹配，则回复false。<br>
(3).如果一个现有的条目与一个新的条目冲突（相同的索引，但不同的任期），则删除现有的条目和它后面的所有条目。<br>
(4).现有日志尚未出现的任何新条目要添加。<br>
(5).如果 leaderCommit > commitIndex，则设置 commitIndex = min(leaderCommit, index of last new entry)。<br>
<br>
4.服务器的规则<br>
对于所有服务器：
(1). 如果 commitIndex > lastApplied: 增加 lastApplied, 应用 log[lastApplied]到状态机。
(2). 如果RPC请求或响应包含term > currentTerm, 则设置 currentTerm = term, 且当前服务器转换为跟随者。
对于追随者：
(1). 对来自候选人和领导者的RPC做出响应。
(2). 如果没有收到来自当前领导者的AppendEntries RPC或授予候选人投票权而选举超时，转换为候选者。
对于候选者：
(1). 在转换为候选者时，开始选举。
(2). 递增currentTerm，并为自己投票，将选举定时器重置。
(3). 向所有其他服务器发送RequestVote RPCs。
(4). 如果收到大多数服务器的投票：成为领导者。
(5). 如果收到来自新领导者的AppendEntries RPC：转换为跟随者。
(6). 如果选举超时：开始新的选举。
对于领导者：
(1). 选举后：在空闲期间重复发送最初的空AppendEntries RPCs(心跳)到每个服务器，以防止选举超时。
(2). 如果收到来自客户端的命令：将条目追加到本地日志，在条目应用于状态机后作出响应。
(3). 如果最后的日志索引≥跟随者的NextIndex：发送AppendEntries RPC，里面包括从nextIndex开始的日志条目。
(4). 如果RPC回复成功：为跟随者更新对应的nextIndex和matchIndex。如果AppendEntries RPC因为日志的不一致而失败，递减nextIndex并重试。
(5). 如果存在一个N，使得N>commitIndex，以及大多数的matchIndex[i] ≥ N，并且 log[N].term == currentTerm：设置commitIndex = N。



