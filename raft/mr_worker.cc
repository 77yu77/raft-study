#include <iostream>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>
#include <algorithm>
#include <mutex>
#include <string>
#include <vector>
#include <map>

#include "rpc.h"
#include "mr_protocol.h"

using namespace std;

struct KeyVal {
    string key;
    string val;
};

int hashMap(string key){
   if(key[0]<='J'){
	   return 0;
   }
   if(key[0]<='Z'){
	   return 1;
   }
   if(key[0]<='j'){
	   return 2;
   }
   return 3;
}
//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
vector<KeyVal> Map(const string &filename, const string &content)
{
	// Copy your code from mr_sequential.cc here.
     string word;
     vector<KeyVal> pairs;
     string num="1";
     for(uint32_t i=0;i<content.size();i++){
        if(((content[i]<='z')&&(content[i]>='a'))||((content[i]<='Z')&&(content[i]>='A'))){
          word.push_back(content[i]);
         // printf("%s\n",word.c_str());
          continue;
        }
        if(!word.empty())
         pairs.push_back({word,num});
        word.clear(); 
     }
     return pairs;   

}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
string Reduce(const string &key, const vector < string > &values)
{
    // Copy your code from mr_sequential.cc here.
    int value=0;
    // printf("reduce\n");
    for(string val:values){
         value+=atoi(val.c_str());
    }
    string sum=to_string(value);
   // printf("reduce:%d",value);
    return sum;

}


typedef vector<KeyVal> (*MAPF)(const string &key, const string &value);
typedef string (*REDUCEF)(const string &key, const vector<string> &values);

class Worker {
public:
	Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf);

	void doWork();

private:
	void doMap(int index, const vector<string> &filenames);
	void doReduce(int index);
	void doSubmit(mr_tasktype taskType, int index);

	mutex mtx;
	int id; 
	 
	rpcc *cl;
	std::string basedir;
	MAPF mapf;
	REDUCEF reducef;
};


Worker::Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf)
{
	this->basedir = dir;
	this->mapf = mf;
	this->reducef = rf;
	sockaddr_in dstsock;
	make_sockaddr(dst.c_str(), &dstsock);
	this->cl = new rpcc(dstsock);
	if (this->cl->bind() < 0) {
		printf("mr worker: call bind error\n");
	}
}

void Worker::doMap(int index, const vector<string> &filenames)
{
	// Lab2: Your code goes here.
	string content;
	getline(ifstream(filenames[index]), content, '\0');
	vector<KeyVal> datas=Map(filenames[index],content);  
    FILE *fp[4];	
	char inputFile[]="mr-00.txt";
	inputFile[3]='0'+index;
	for(int i=0;i<4;i++){
		inputFile[4]='0'+i;
		fp[i]=fopen(inputFile,"w+"); 
	}
	for(int j=0;j<datas.size();j++){
		fprintf(fp[hashMap(datas[j].key)],"%s %s ",datas[j].key.data(),datas[j].val.data());
	}
	for(int i=0;i<4;i++){
	fclose(fp[i]);
	}   
    
}

void Worker::doReduce(int index)
{
	// Lab2: Your code goes here.
	//printf("doReduce\n");
	string inputFile="mr-00.txt";
	inputFile[4]='0'+index;
	vector<KeyVal> datas;
	for(int i=0;i<6;i++){
		inputFile[3]='0'+i;
		string content;
		getline(ifstream(inputFile),content,'\0');
		istringstream str(content);
		string key;
		string value;
		while(str>>key){
			str>>value;
			datas.push_back({key,value});
		}
	   }	
	char file[]="mr-out-0.txt";
	file[7]='0'+index;
	FILE *fp=fopen(file,"w+");
    sort(datas.begin(), datas.end(),
    	[](KeyVal const & a, KeyVal const & b) {	
		return a.key < b.key;
	});	
    for (unsigned int i = 0; i < datas.size();) {
        unsigned int j = i + 1;
        for (; j <datas.size() &&  datas[j].key == datas[i].key;)
            j++;
        vector <string> values;
        for (unsigned int k = i; k < j; k++) {
            values.push_back(datas[k].val);
        }
        string output = Reduce(datas[i].key, values);
		fprintf(fp,"%s %s\n",datas[i].key.data(),output.data());
        i = j;
    }
	fclose(fp);
}

void Worker::doSubmit(mr_tasktype taskType, int index)
{
	bool b;
	mr_protocol::status ret = this->cl->call(mr_protocol::submittask, taskType, index, b);	
	if (ret != mr_protocol::OK) {
		fprintf(stderr, "submit task failed\n");
		exit(-1);
	}
}

void Worker::doWork()
{  
    mr_protocol::AskTaskResponse response;
	mr_protocol::status ret;
	int a=0;
	for (;;) {		
		//
		// Lab2: Your code goes here.
		// Hints: send asktask RPC call to coordinator
		// if mr_tasktype::MAP, then doMap and doSubmit
		// if mr_tasktype::REDUCE, then doReduce and doSubmit
		// if mr_tasktype::NONE, meaning currently no work is needed, then sleep
		//    
        ret=this->cl->call(mr_protocol::asktask,a,response);
		//cout<<response.index<<" "<<response.taskType<<""<<ret<<endl;
	    if (ret!= mr_protocol::OK) {
		 fprintf(stderr, "submit task failed\n");
		 exit(-1);
	    }
		if(response.taskType==mr_tasktype::MAP){
			//cout << "domap " << response.index << endl;
            doMap(response.index,response.filenames);
			//cout<<"sunmit"<<endl;
		    doSubmit((mr_tasktype)response.taskType,response.index);
		}
		else if(response.taskType==mr_tasktype::REDUCE){
		//	cout << "doreduce " << response.index << endl;
            doReduce(response.index);
			doSubmit((mr_tasktype)response.taskType,response.index);
		}
		else{
		  sleep(1);	
		}

	}
}

int main(int argc, char **argv)
{
	if (argc != 3) {
		fprintf(stderr, "Usage: %s <coordinator_listen_port> <intermediate_file_dir> \n", argv[0]);
		exit(1);
	}

	MAPF mf = Map;
	REDUCEF rf = Reduce;	
	Worker w(argv[1], argv[2], mf, rf);
	w.doWork();

	return 0;
}

